<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>40423226個人網誌 (虎尾科大MDE)</title><link href="./" rel="alternate"></link><link href="./feeds/all.atom.xml" rel="self"></link><id>./</id><updated>2222-02-22T22:22:00+08:00</updated><entry><title>Onshape</title><link href="./onshape.html" rel="alternate"></link><published>2222-02-22T22:22:00+08:00</published><updated>2222-02-22T22:22:00+08:00</updated><author><name>40423226</name></author><id>tag:,2222-02-22:./onshape.html</id><summary type="html">&lt;h2&gt;&lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt;&lt;/h2&gt;</summary><category term="Onshape"></category></entry><entry><title>SolveSpace</title><link href="./solvespace.html" rel="alternate"></link><published>2222-02-22T22:22:00+08:00</published><updated>2222-02-22T22:22:00+08:00</updated><author><name>40423226</name></author><id>tag:,2222-02-22:./solvespace.html</id><summary type="html">&lt;h2&gt;&lt;a href="http://solvespace.com/"&gt;SolveSpace&lt;/a&gt;&lt;/h2&gt;

&lt;h2&gt;SolveSpace 2D&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/192920828" width="640" height="428" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;2D成品圖&lt;/p&gt;

&lt;p&gt;&lt;img src="../data/image/solvespace 2D.png" width="800" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;SolveSpace 3D&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/192920873" width="640" height="428" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;3D成品圖&lt;/p&gt;

&lt;p&gt;&lt;img src="../data/image/solvespace 3D.png" width="800" /&gt;&lt;/p&gt;
&lt;h2&gt;組合圖&lt;/h2&gt;

&lt;p&gt;Cube&lt;/p&gt;

&lt;iframe src="../data/solvespace/cube.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;p&gt;Strut&lt;/p&gt;

&lt;iframe src="../data/solvespace/strut.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;p&gt;組合&lt;/p&gt;

&lt;iframe src="../data/solvespace/cube_strut.html" width="800" height="600"&gt;&lt;/iframe&gt;</summary><category term="SolveSpace"></category></entry><entry><title>20161125W11</title><link href="./20161125w11.html" rel="alternate"></link><published>2016-11-25T12:00:00+08:00</published><updated>2016-11-25T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-11-25:./20161125w11.html</id><summary type="html">&lt;h2&gt;&lt;a href="http://140.130.31.20/march/nfu.html#"&gt;虎科大36週年校慶&lt;/a&gt;&lt;/h2&gt;</summary><category term="虎科大36週年校慶"></category></entry><entry><title>利用 Git submodule 功能進行組員資料設計整合</title><link href="./li-yong-git-submodule-gong-neng-jin-xing-zu-yuan-zi-liao-she-ji-zheng-he.html" rel="alternate"></link><published>2016-11-24T15:00:00+08:00</published><updated>2016-11-24T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-24:./li-yong-git-submodule-gong-neng-jin-xing-zu-yuan-zi-liao-she-ji-zheng-he.html</id><summary type="html">&lt;p&gt;電腦輔助設計流程中, 利用 git submodule 指令, 可以整合組員所提供的設計資料、設計程式與設計零組件.&lt;/p&gt;


&lt;p&gt;引用子模組中的四連桿繞行軌跡點座標資料, 進行繪圖的範例: &lt;a href="https://scrum-1.github.io/2016fallcadp_ag100/blog/git-submodule-zai-dian-nao-fu-zhu-she-ji-shang-de-ying-yong.html"&gt;https://scrum-1.github.io/2016fallcadp_ag100/blog/git-submodule-zai-dian-nao-fu-zhu-she-ji-shang-de-ying-yong.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;引用組員設計程式的範例:&lt;/p&gt;
&lt;p&gt;引用組員的設計零組件範例:&lt;/p&gt;
&lt;p&gt;利用 github 所提供的 stl 零件格式展示, 或 Solvespace 的零件 .js 格式, 將組員分別完成的 OnShape 課程零組件, 透過子模組設定, 展示在各分組的網誌中.&lt;/p&gt;</summary><category term="使用導引"></category><category term="Brython"></category><category term="git"></category><category term="submodule"></category></entry><entry><title>Brython 動畫測試</title><link href="./brython-dong-hua-ce-shi.html" rel="alternate"></link><published>2016-11-20T15:00:00+08:00</published><updated>2016-11-20T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-20:./brython-dong-hua-ce-shi.html</id><summary type="html">&lt;p&gt;Brython 動畫測試&lt;/p&gt;


&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 
以下實際利用  Brython 執行繪圖 
程式來源: http://stackoverflow.com/questions/39689555/simple-image-rotation-with-python-and-dom-using-rapydscript
--&gt;

&lt;script type='text/python3'&gt;
from browser import window, timer, document, html
import time

t0 = time.time()

def user_agent():
   """ Helper function for determining the user agent """
   if window.navigator.userAgent.find('Chrome'):
       return 'chrome'
   elif window.navigator.userAgent.find('Firefox'):
       return 'firefox'
   elif window.navigator.userAgent.find('MSIE'):
       return 'msie'
   elif window.navigator.userAgent.find('Opera'):
       return 'opera'

# Dict Mapping UserAgents to Transform Property names
# 在不同的瀏覽器, 有不同的 transform 名稱
rotate_property = {
   'chrome':'WebkitTransform',
   'firefox':'MozTransform',
   'msie':'msTransform',
   'opera':'OTransform'
}

degrees = 0
def animation_step(elem_id):
   """ Called every 30msec to increase the rotatation of the element. """
   global degrees, tm

   # Get the right property name according to the useragent
   agent = user_agent()
   prop = rotate_property.get(agent,'transform')

   # Get the element by id
   el = document[elem_id]

   # Set the rotation of the element
   # 設定 element 的旋轉屬性
   setattr(el.style, prop, "rotate("+str(degrees)+"deg)")
   # 將旋轉角度寫在 id 為 status 的區域
   document['status'].innerHTML = "rotate("+str(degrees)+" deg)"

   # Increase the rotation
   degrees += 1
   if degrees &gt; 360:
       # Stops the animation after 360 steps
       timer.clear_interval(tm)
       degrees = 0

# Start the animation
# 每 30 msec 重新刷新繪圖
tm = timer.set_interval(lambda id='img1':animation_step(id), 30)
# 將執行所花費時間, 寫在 id="status3" 的標註區域
document['status3'].innerHTML = "執行所花費時間: ("+str(time.time()-t0)+" ms)"

&lt;/script&gt;

&lt;!-- 以下利用 img 標註, 選擇位於 data 目錄下的 png 圖檔 --&gt;

&lt;p&gt;&lt;img id="img1" src="./../data/guitar_chord.png" alt="cog1"&gt;
&lt;div id="status"&gt;&lt;/div&gt;
&lt;div id="status3"&gt;&lt;/div&gt;&lt;/p&gt;</summary><category term="使用導引"></category><category term="Brython"></category></entry><entry><title>20161118W10</title><link href="./20161118w10.html" rel="alternate"></link><published>2016-11-18T12:00:00+08:00</published><updated>2016-11-18T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-11-18:./20161118w10.html</id><summary type="html">&lt;p&gt;有關 Solvespace 機構模擬功能介紹, 與 Python3 及 Brython 程式驗證&lt;/p&gt;


&lt;h2&gt;Solvespace 平面四連桿機構模擬&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/192930481" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;路徑圖&lt;/p&gt;

&lt;p&gt;&lt;img src="../data/image/solvespace.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;將所得到的點座標 .csv 以 Excel 畫圖, 得到:&lt;/p&gt;
&lt;p&gt;&lt;img src="../data/image/Excel.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Python3 平面四連桿機構模擬:&lt;/p&gt;
&lt;p&gt;接下來利用三角函數推導四連桿機構的運動模擬, 即已知長度 18 公分的連桿以逆時針方向旋轉, 希望求三角形頂點的運動座標.&lt;/p&gt;
&lt;p&gt;首先利用 Brython, 讀取 data 目錄中的 cadpa_w10_4bar.csv 座標檔案, 然後以 splitlines() 及 split() 取出各點的 x 座標與 y 座標後, 將點連成路徑曲線如下:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫兩條直線 --&gt;

&lt;canvas id="fourbar" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# 準備繪圖畫布
canvas = doc["fourbar"]
container1 = doc['container1']
ctx = canvas.getContext("2d")

fourbar_data = open("./../data/cadpa_w10_4bar.csv").read()
fourbar_list = fourbar_data.splitlines()
#container1 &lt;= fourbar_list[0]
# 以下可以利用 ctx 物件進行畫圖
# 先畫一條直線
ctx.beginPath()
# 設定線的寬度為 1 個單位
ctx.lineWidth = 1
# 利用 transform 將 y 座標反轉, 且 offset canvas.height
# (X scale, X skew, Y skew, Y scale, X offset, Y offset)
# 配合圖形位置進行座標轉換
ctx.transform(1, 0, 0, -1, canvas.width/2+250, canvas.height/2+100)
# 畫出 x 與 y 座標線
# 各座標值放大 8 倍
ratio = 8
'''
ctx.moveTo(0, 0)
ctx.lineTo(0, 100)
ctx.moveTo(0, 0)
ctx.lineTo(100, 0)
'''
ctx.moveTo(0, 0)
ctx.lineTo(-30*ratio, 0)
start_point = fourbar_list[0].split(",")
ctx.moveTo(float(start_point[0])*ratio, float(start_point[1])*ratio)
count = 0
for data in fourbar_list[1:]:
    point = data.split(",")
    #count = count + 1
    #container1 &lt;= str(count) + ":" + point[0] + "," + point[1]
    #container1 &lt;= html.BR()
    ctx.lineTo(float(point[0])*ratio, float(point[1])*ratio)
# 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
ctx.strokeStyle = "blue"
# 實際執行畫線
ctx.stroke()
ctx.closePath()
&lt;/script&gt;

&lt;p&gt;Ubuntu 安裝 matplotlib:&lt;/p&gt;
&lt;p&gt;sudo apt-get install python3-matplotlib&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import math
import time
# 利用 matplotlib 程式庫畫出 contour 輪廓
import matplotlib.pyplot as plt

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )


# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp

    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp

# 以上為相關函式物件的定義區
# 全域變數
midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []

# 幾何位置輸入變數
x=10
y=10
r=10

# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
p1 =  Point(150,100)
p2 =  Point(150,200)
p3 =  Point(300,300)
p4 =  Point(350,100)

#create links
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)

link2_len = p2.distance(p3)
link3_len = p3.distance(p4)

triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)

def simulate():
    global theta, midpt, oldpt
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    # 印出座標點
    #print(round(tippt.x, 2), round(tippt.y, 2))
    if theta &lt; 360:
        contour.append((round(tippt.x, 2), round(tippt.y, 2)))

for i in range(180):
    simulate()
# 印出 contour 
#print(contour)

x_list = [x for (x, y) in contour]
y_list = [y for (x, y) in contour]

plt.xlabel('x coordinate')
plt.ylabel('y coordinate')

plt.plot(x_list, y_list)
plt.show()
&lt;/pre&gt;

&lt;p&gt;以下將上述四連桿模擬程式移到近端的 Jupyter 平台中執行:&lt;/p&gt;
&lt;p&gt;以下將上述四連桿模擬程式移到 Jupyterhub 平台中執行:&lt;/p&gt;
&lt;p&gt;以下再利用 Brython 繪出四連桿模擬特定點的掃掠圖:&lt;/p&gt;
&lt;p&gt;以下利用 Brython 動態畫出四連桿機構模擬圖:&lt;/p&gt;
&lt;p&gt;以下利用 Solvespace 繪圖法進行相同機構模擬驗證:&lt;/p&gt;
&lt;p&gt;以下再利用 Solvespace 程式 API 方法進行四連桿模擬驗證:&lt;/p&gt;
&lt;p&gt;以下以 Delta 3D 印表機印出連桿零件, 組立後以步進馬達驅動進行驗證:&lt;/p&gt;
&lt;p&gt;以下利用伸縮連桿設計, 以 Delta 3D 印表機印出連桿零件, 組立後以步進馬達驅動進行驗證:&lt;/p&gt;
&lt;p&gt;請以上述相同流程, 模擬並實作驗證 &lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿機構&lt;/a&gt;的作動.&lt;/p&gt;</summary><category term="上課內容"></category><category term="SolveSpace"></category></entry><entry><title>2016Fall 期中摘要</title><link href="./2016fall-qi-zhong-zhai-yao.html" rel="alternate"></link><published>2016-11-17T15:00:00+08:00</published><updated>2016-11-17T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-17:./2016fall-qi-zhong-zhai-yao.html</id><summary type="html">&lt;p&gt;經過 9 個禮拜, 電腦輔助設計實習課程到底學到什麼?&lt;/p&gt;


&lt;h2&gt;沒有 OpenShift 與 copy.com 之後&lt;/h2&gt;
&lt;p&gt;首先必須說明的是, 本課程在 2016 Fall, 為了因應 OpenShift 無法提供每一個學員免費雲端空間, 而且 copy.com 也終止服務之後, 從電腦輔助設計實習走向協同產品設計實習, 只剩下 Github 以及自己架設的伺服器. 因此本學期的所有教學運作全部在 Github 平台上執行, 每一位學員都必須申請 Github 帳號, 並且利用 html5 以及 Javascript 來維護自己倉儲中 gh-pages 分支上的資料.&lt;/p&gt;
&lt;p&gt;面對這樣的轉變, 在目前這個 Leo Editor 專案中, 特別建立了一個近端的 https 伺服器按鈕, 而且為了能夠獨立於 Leo Editor 運作, 特別採用執行緒的架構編寫:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 8443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("8443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;

&lt;p&gt;使用者只要將滑鼠停在 https-server 按鈕所在節點, 然後按下 Leo Editor 上方的對應按鈕, 就可以在近端電腦上執行一個 https 伺服器, 啟動之後, 只要利用瀏覽器連結 https://localhost:8443, 就可以得到與 Github pages 上相同的執行結果.&lt;/p&gt;
&lt;p&gt;儘管在這個 https 伺服器中只能運行 html5 與 Javascript, 但是為了配合計算機程式的 Python3, 電腦輔助設計實習並不直接讓學員編寫 Javascript, 而是透過 Brython 執行網頁上的 Python3 格式程式, 本學期主要透過 html5 中的 canvas 繪圖來模擬平面多連桿機構的運動, 並且利用 Solvespace 與 OnShape 結合 V-rep 進行驗證, 當然最終理想, 是可以將平面多連桿機構以 3D 印表機列印出零組件, 然後透過步進馬達驅動, 讓學員有機會接觸機電資 (InfoRmechAtronic) 整合的實習.&lt;/p&gt;
&lt;p&gt;另外, 由於 2016 Fall CADP 課程規劃為一個全新的內容組合, 從 Github Pages 的網誌搭建作為開端, reveal.js 的網際投影片作為輔助簡報, 至於 Github Wiki 則充當數位筆記本, 專門用來收集零碎的參考資料.&lt;/p&gt;
&lt;p&gt;上述 Pelican 網誌、reveal.js 簡報與 Github Wiki 其實有許多重複的展示資料, 原本可以透過 Leo Editor 的 clone node 與 Github 的 &lt;a href="https://help.github.com/articles/adding-and-editing-wiki-pages-locally/"&gt;本地 wiki 維護&lt;/a&gt; 說明, 統一整合在 Leo Editor 專案中, 但是需要 @clean 與 @others 以及命名節點等進階 Leo 指令的導入, 目前尚未納入課程.&lt;/p&gt;
&lt;h2&gt;Git submodule 的應用&lt;/h2&gt;
&lt;p&gt;這個學期首度在 CADP 課程中導入 git submodule, 主要是為了配合協同設計流程中的模擬程式呼叫, 讓組員間可以透過子模組的架構, 決定程式與設計資料的版次後, 彼此引用協同資料. 只是目前採用全班分組子模組的架構, 只要一個組員設定出錯, 全班的 gh-pages 網頁就無法更新, 因此從第 11 週起, 將改為組員自行建立子模組的程式與資料協同, 然後擴充到各組, 若各組運作正常, 待協同產品設計實習課程階段, 再推展到班級子模組協同.&lt;/p&gt;
&lt;p&gt;最後, 本課程網誌前面各筆資料的大架構雖然已經決定, 但是執行細節與範圍仍然必須配合學員的學習結果, 再逐一放入內容, 因此, 各筆資料在課程結束之前, 將會持續更新.&lt;/p&gt;</summary><category term="使用導引"></category><category term="期中"></category></entry><entry><title>20161111W9</title><link href="./20161111w9.html" rel="alternate"></link><published>2016-11-11T12:00:00+08:00</published><updated>2016-11-11T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-11-11:./20161111w9.html</id><summary type="html">&lt;h2&gt;&lt;a href="http://mde.tw/2016fallcadp/blog/2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html"&gt;檢查自己的連結是否正確&lt;/a&gt;&lt;/h2&gt;</summary><category term="上課內容"></category></entry><entry><title>2016Fall Delta 3D 印表機設計</title><link href="./2016fall-delta-3d-yin-biao-ji-she-ji.html" rel="alternate"></link><published>2016-11-06T15:00:00+08:00</published><updated>2016-11-06T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-delta-3d-yin-biao-ji-she-ji.html</id><summary type="html">&lt;p&gt;各組自行透過 &lt;a href="http://tw.misumi-ec.com/"&gt;http://tw.misumi-ec.com/&lt;/a&gt; 尋找適用的標準零件, 下載 2D 與 3D 零件圖檔, 利用 Solvespace 與 OnShape 進行設計組立與模擬後, 實際下單購買各零組件, 完成 3D 印表機的設計與實作.&lt;/p&gt;
</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall Onshape 教學</title><link href="./2016fall-onshape-jiao-xue.html" rel="alternate"></link><published>2016-11-06T14:00:00+08:00</published><updated>2016-11-06T14:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-onshape-jiao-xue.html</id><summary type="html">&lt;p&gt;有關 Onshape 零件, 組件, 機構模擬等功能介紹, FeatureScript 與協同設計等&lt;/p&gt;


&lt;p&gt;各組以每週完成 3 個 weeks 的 Onshape 標準 College Curriculum 教材後, 根據 &lt;a href="http://chiamingyen.github.io/kmolab_data/files/ProEMechanism.pdf"&gt;http://chiamingyen.github.io/kmolab_data/files/ProEMechanism.pdf&lt;/a&gt; 說明完成零件繪製與組立後,  如何精確得知機構運動過程的約束位置?&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall 平面機構模擬</title><link href="./2016fall-ping-mian-ji-gou-mo-ni.html" rel="alternate"></link><published>2016-11-06T13:00:00+08:00</published><updated>2016-11-06T13:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-ping-mian-ji-gou-mo-ni.html</id><summary type="html">&lt;p&gt;有關 Solvespace 機構模擬功能介紹, 與 Python3 及 Brython 程式驗證&lt;/p&gt;


&lt;h2&gt;Solvespace 平面四連桿機構模擬&lt;/h2&gt;
&lt;p&gt;直接利用 Solvespace Analyze-Trace Point-Stop Trace 得到下列繞行路徑:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/cadpa_w10_4bar.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;將所得到的點座標 .csv 以 Excel 畫圖, 得到:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/cadpa_w10_4bar_excel.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Python3 平面四連桿機構模擬:&lt;/p&gt;
&lt;p&gt;接下來利用三角函數推導四連桿機構的運動模擬, 即已知長度 18 公分的連桿以逆時針方向旋轉, 希望求三角形頂點的運動座標.&lt;/p&gt;
&lt;p&gt;首先利用 Brython, 讀取 data 目錄中的 cadpa_w10_4bar.csv 座標檔案, 然後以 splitlines() 及 split() 取出各點的 x 座標與 y 座標後, 將點連成路徑曲線如下:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫兩條直線 --&gt;

&lt;canvas id="fourbar" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# 準備繪圖畫布
canvas = doc["fourbar"]
container1 = doc['container1']
ctx = canvas.getContext("2d")

fourbar_data = open("./../data/cadpa_w10_4bar.csv").read()
fourbar_list = fourbar_data.splitlines()
#container1 &lt;= fourbar_list[0]
# 以下可以利用 ctx 物件進行畫圖
# 先畫一條直線
ctx.beginPath()
# 設定線的寬度為 1 個單位
ctx.lineWidth = 1
# 利用 transform 將 y 座標反轉, 且 offset canvas.height
# (X scale, X skew, Y skew, Y scale, X offset, Y offset)
# 配合圖形位置進行座標轉換
ctx.transform(1, 0, 0, -1, canvas.width/2+250, canvas.height/2+100)
# 畫出 x 與 y 座標線
# 各座標值放大 8 倍
ratio = 8
'''
ctx.moveTo(0, 0)
ctx.lineTo(0, 100)
ctx.moveTo(0, 0)
ctx.lineTo(100, 0)
'''
ctx.moveTo(0, 0)
ctx.lineTo(-30*ratio, 0)
start_point = fourbar_list[0].split(",")
ctx.moveTo(float(start_point[0])*ratio, float(start_point[1])*ratio)
count = 0
for data in fourbar_list[1:]:
    point = data.split(",")
    #count = count + 1
    #container1 &lt;= str(count) + ":" + point[0] + "," + point[1]
    #container1 &lt;= html.BR()
    ctx.lineTo(float(point[0])*ratio, float(point[1])*ratio)
# 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
ctx.strokeStyle = "blue"
# 實際執行畫線
ctx.stroke()
ctx.closePath()
&lt;/script&gt;

&lt;p&gt;Ubuntu 安裝 matplotlib:&lt;/p&gt;
&lt;p&gt;sudo apt-get install python3-matplotlib&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import math
import time
# 利用 matplotlib 程式庫畫出 contour 輪廓
import matplotlib.pyplot as plt

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )


# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp

    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp

# 以上為相關函式物件的定義區
# 全域變數
midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []

# 幾何位置輸入變數
x=10
y=10
r=10

# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
p1 =  Point(150,100)
p2 =  Point(150,200)
p3 =  Point(300,300)
p4 =  Point(350,100)

#create links
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)

link2_len = p2.distance(p3)
link3_len = p3.distance(p4)

triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)

def simulate():
    global theta, midpt, oldpt
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    # 印出座標點
    #print(round(tippt.x, 2), round(tippt.y, 2))
    if theta &lt; 360:
        contour.append((round(tippt.x, 2), round(tippt.y, 2)))

for i in range(180):
    simulate()
# 印出 contour 
#print(contour)

x_list = [x for (x, y) in contour]
y_list = [y for (x, y) in contour]

plt.xlabel('x coordinate')
plt.ylabel('y coordinate')

plt.plot(x_list, y_list)
plt.show()
&lt;/pre&gt;

&lt;p&gt;以下將上述四連桿模擬程式移到近端的 Jupyter 平台中執行:&lt;/p&gt;
&lt;p&gt;以下將上述四連桿模擬程式移到 Jupyterhub 平台中執行:&lt;/p&gt;
&lt;p&gt;以下再利用 Brython 繪出四連桿模擬特定點的掃掠圖:&lt;/p&gt;
&lt;p&gt;以下利用 Brython 動態畫出四連桿機構模擬圖:&lt;/p&gt;
&lt;p&gt;以下利用 Solvespace 繪圖法進行相同機構模擬驗證:&lt;/p&gt;
&lt;p&gt;以下再利用 Solvespace 程式 API 方法進行四連桿模擬驗證:&lt;/p&gt;
&lt;p&gt;以下以 Delta 3D 印表機印出連桿零件, 組立後以步進馬達驅動進行驗證:&lt;/p&gt;
&lt;p&gt;以下利用伸縮連桿設計, 以 Delta 3D 印表機印出連桿零件, 組立後以步進馬達驅動進行驗證:&lt;/p&gt;
&lt;p&gt;請以上述相同流程, 模擬並實作驗證 &lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿機構&lt;/a&gt;的作動.&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall Solvespace 教學</title><link href="./2016fall-solvespace-jiao-xue.html" rel="alternate"></link><published>2016-11-06T12:00:00+08:00</published><updated>2016-11-06T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-solvespace-jiao-xue.html</id><summary type="html">&lt;p&gt;有關 Solvespace 零件, 組件, 機構模擬等功能介紹, 程式編譯與 API 延伸等&lt;/p&gt;


&lt;h2&gt;Solvespace&lt;/h2&gt;
&lt;h3&gt;1. Parts (零件繪製)&lt;/h3&gt;
&lt;p&gt;範例檔案: &lt;a href="http://solvespace.com/bracket.pl"&gt;http://solvespace.com/bracket.pl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;An introductory tutorial is available, in which we draw the same part that is shown in the demo video. &lt;/p&gt;
&lt;p&gt;This covers most of the basic features of SolveSpace, including sketches, constraints, extrusions, and Boolean operations.&lt;/p&gt;
&lt;p&gt;When we first run SolveSpace, we will begin with an empty part. Initially, our view of the part will be oriented onto the XY plane; the label for that plane is displayed at the bottom left of the screen (#XY, in dark grey). The axes are also indicated by the three colored arrows at the bottom left; the X, Y, and Z axes are drawn in red, green, and blue respectively.&lt;/p&gt;
&lt;p&gt;When we hover the mouse over any entity, constraint, or other object in the sketch, that object will appear highlighted in yellow. For example, the XY plane, which is drawn as a dashed square, will appear highlighted when we hover the mouse over it. The YZ and ZX planes initially look like dashed lines, because they are being viewed on edge; but they still appear highlighted in yellow when we hold the mouse over them. It is similarly possible to highlight the X, Y, and Z axes (which are drawn as arrows), or the origin (which like all points is drawn as a green square).&lt;/p&gt;
&lt;h4&gt;Extrude (平行長出或除料)&lt;/h4&gt;
&lt;h4&gt;Lathe (旋轉繞行長出或除料)&lt;/h4&gt;
&lt;h4&gt;零組件繪圖練習&lt;/h4&gt;
&lt;p&gt;利用 Solvespace, 以 &lt;a href="./../data/w12/College_Student_Primer_Creo_2.pdf"&gt;College_Student_Primer_Creo_2.pdf&lt;/a&gt; 為範本, 編寫一本 Solvespace 零組件導引 pdf 手冊.&lt;/p&gt;
&lt;p&gt;利用 .md 檔案格式編寫, 建立導引手冊所需的圖文資料後, 設法利用 Pandoc 與 LaTeX 轉為 html 與 pdf 檔案.&lt;/p&gt;
&lt;p&gt;首先必須設法編譯 Solvespace 原始碼, 取得 Windows 10 64 位元與 Ubuntu 16.04 64 位元環境下執行的 solvespace.exe 與 solvespace.&lt;/p&gt;
&lt;p&gt;啟動 Solvespace 後, 在 View 功能表下確定所使用的尺寸單位, 選擇 mm 作為繪圖單位.&lt;/p&gt;
&lt;p&gt;根據尺寸繪製一個 block.&lt;/p&gt;
&lt;h4&gt;Export Triangle Mesh&lt;/h4&gt;
&lt;p&gt;STL 格式&lt;/p&gt;
&lt;p&gt;將零件檔案轉出 STL 格式後 (binary or ASCII format definitions), 進入倉儲後, 利用 &lt;a href="https://help.github.com/articles/3d-file-viewer/"&gt;Github 內建的 stl viewer 功能&lt;/a&gt;展示.&lt;/p&gt;
&lt;p&gt;three.js&lt;/p&gt;
&lt;iframe src="./../data/threejs/donut.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="./../data/w12/College_Student_Primer_Creo_2.pdf"&gt;W12 組立&lt;/a&gt;&lt;/p&gt;
&lt;iframe src="./../data/threejs/w12.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/threejs/w12b.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;h3&gt;2. Assembly (零件組立)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://solvespace.com/box.pl"&gt;http://solvespace.com/box.pl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To start, we would like to define the orientation of the part. We can do that by locking one of the part's normals in the same orientation as one of our coordinate axes. Here, a good choice would be to constrain any of the base's normals—which are drawn as blue arrows—in the same orientation as our coordinate system's Z axis, which is also drawn as a blue arrow, in this view pointing approximately up from the origin. Select those two normals by left-clicking them, and choose Constrain → Same Orientation, or the equivalent constraint from the toolbar.&lt;/p&gt;
&lt;p&gt;The two normals are now each marked with a magenta X, which is visible above. (It doesn't matter which of the normals on the part were chosen to constrain, since they all point in the same direction. The choice is arbitrary.) This means that those two normals are constrained to point in the same direction (i.e., parallel); but it also locks the twist of the part about that axis, so it fully constrains the part's orientation. The same-orientation constraint is useful, because it completely specifies a part's orientation with a single constraint.&lt;/p&gt;
&lt;p&gt;We can try to drag the part's orientation and rotation now. We will find that it is still possible to translate the part anywhere, but impossible to rotate it, because that rotation is now fixed. To define the translation, we can use a point-coincident constraint. Select the two points marked in red in the image above, and choose Constrain → On Point. The two points will now be constrained to be coincident, locking the imported part's translation. The imported part is now fully constrained.&lt;/p&gt;
&lt;h3&gt;3. Linkages (fourbar &amp;amp; multilink) (四連桿與多連桿運動模擬)&lt;/h3&gt;
&lt;p&gt;四連桿:&lt;/p&gt;
&lt;p&gt;多連桿:  &lt;a href="http://solvespace.com/linkage.pl"&gt;http://solvespace.com/linkage.pl&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4. Compiled &amp;amp; API (編譯與延伸應用)&lt;/h3&gt;
&lt;p&gt;使用 Virtualbox 虛擬主機執行 Windows 64 位元與 Ubuntu 64 位元環境中的編譯與延伸應用.&lt;/p&gt;
&lt;p&gt;Virtualbox Ubuntu 64位元虛擬檔案: &lt;a href="http://140.130.17.17/public/Ubuntu/1604_solvespace_final/Ubuntu_160464.vdi"&gt;http://140.130.17.17/public/Ubuntu/1604_solvespace_final/Ubuntu_160464.vdi&lt;/a&gt; (只有在區網可以下載)&lt;/p&gt;
&lt;p&gt;在虛擬主機中完成 Solvespace 編譯與執行的參考畫面:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/solvespace/cadpa_w11_solvespace_compiled.png" width="800" /&gt;&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall 機械設計主題教學</title><link href="./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html" rel="alternate"></link><published>2016-11-06T11:00:00+08:00</published><updated>2016-11-06T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html</id><summary type="html">&lt;p&gt;知識管理與最佳化應用實驗室試圖利用計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 進行與機械設計相關的主題式教學, 其中包含強化創造力的教學、令學員熟習六種工程表達方式, 並且俱備融入協同設計所需要的四大面向知識與技能.&lt;/p&gt;


&lt;h1&gt;機械設計主題教學&lt;/h1&gt;
&lt;p&gt;創造力三元素, 機械設計的六種表達, 協同設計的四大面向.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;強化創造能力 - 自學力、程式力與想像力
(Creative Competencies)&lt;/li&gt;
&lt;li&gt;熟習六種表達  - 口語、文字、2D、3D、理論與實體表達
(Six Presentation Methods)&lt;/li&gt;
&lt;li&gt;融入協同設計 - 電腦、網路、軟硬體工具與協同專案
(Collaborative Designs)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2016 Fall CADP 課程資料檢視:&lt;/p&gt;
&lt;p&gt;將要以 Brython 讀取兩班修課名單與分組名單, 並根據作業倉儲規劃, &lt;/p&gt;
&lt;p&gt;以各班 submodule 分組檢視 (必須各組與各成員 submodule 設置正確):&lt;/p&gt;
&lt;p&gt;各成員 submodule 架構檢視 (必須各組與各成員 submodule 設置正確):&lt;/p&gt;
&lt;p&gt;各班各組直接檢視:&lt;/p&gt;
&lt;p&gt;電腦輔助設計實習甲班成員連結:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下利用 Brython 程式執行檔案讀取與比對流程 --&gt;

&lt;!-- 假如需要用圖型表示數字, 則利用 canvas 繪圖 --&gt;

&lt;!-- &lt;canvas id="plotarea" width="600" height="400"&gt;&lt;/canvas&gt; --&gt;

&lt;p&gt;甲班學員投影片:&lt;/p&gt;
&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script1"&gt;
from browser import document, html
container1 = document['container1']
adata = open("./../users/a.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://"+str(stud_num)+".github.io/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container1 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
甲班學員網誌:&lt;/p&gt;
&lt;div id="container2"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script2"&gt;
from browser import document, html
from script1 import alist
container2 = document['container2']
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://"+str(stud_num)+".github.io/2016fallcadp_hw/blog")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container2 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
甲班學員 wiki:&lt;/p&gt;
&lt;div id="container3"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script3"&gt;
from browser import document, html
from script1 import alist
container3 = document['container3']
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://github.com/"+str(stud_num)+"/2016fallcadp_hw/wiki")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container3 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
甲班學員倉儲:&lt;/p&gt;
&lt;div id="container4"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script4"&gt;
from browser import document, html
from script1 import alist
container4 = document['container4']
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://github.com/"+str(stud_num)+"/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container4 &lt;= mlink
&lt;/script&gt;

&lt;hr&gt;

&lt;p&gt;乙班學員投影片:&lt;/p&gt;
&lt;div id="container5"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script5"&gt;
from browser import document, html
container5 = document['container5']
adata = open("./../users/b.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://"+str(for_link)+".github.io/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container5 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
乙班學員網誌:&lt;/p&gt;
&lt;div id="container6"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script6"&gt;
from browser import document, html
from script5 import alist
container6 = document['container6']
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://"+str(for_link)+".github.io/2016fallcadp_hw/blog")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container6 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
乙班學員 wiki:&lt;/p&gt;
&lt;div id="container7"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script7"&gt;
from browser import document, html
from script5 import alist
container7 = document['container7']
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://github.com/"+str(for_link)+"/2016fallcadp_hw/wiki")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container7 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
乙班學員倉儲:&lt;/p&gt;
&lt;div id="container8"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script8"&gt;
from browser import document, html
from script5 import alist
container8 = document['container8']
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://github.com/"+str(for_link)+"/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container8 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
各班各組成員 submodule 架構檢視 (必須各組 submodule 設置正確:&lt;/p&gt;
&lt;p&gt;各成員直接檢視:&lt;/p&gt;
&lt;p&gt;以下為分組資料處理程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
content = open("2016fall_cadp_a_groups.txt").read()
#print(content)
result = content.splitlines()
#print(result)
gno = 1
for i in range(len(result)):
    #print(result[i])
    group = result[i].split(":")
    #列出組序
    print("&amp;lt;a href='../g"+str(gno)+"'&amp;gt;第"+str(gno)+"組&amp;lt;/a&amp;gt;:&amp;lt;br /&amp;gt;")
    #print("第"+str(gno)+"組:&amp;lt;br /&amp;gt;")
    #取 group 第2成員, 用逗點隔開納入數列後, 利用[:-1]去掉最後空白
    #print(group[1].split(",")[:-1])
    gmember = group[1].split(",")[:-1]
    for j in range(len(gmember)):
        #print(gmember[j])
        print("&amp;lt;a href='../g"+str(gno)+"/"+str(gmember[j])+"'&amp;gt;"+ \
        str(gmember[j])+"&amp;lt;/a&amp;gt; ")
    print("&amp;lt;br /&amp;gt;")
    gno = gno + 1
&lt;/pre&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>20161104W8</title><link href="./20161104w8.html" rel="alternate"></link><published>2016-11-04T12:00:00+08:00</published><updated>2016-11-04T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-11-04:./20161104w8.html</id><summary type="html">&lt;h2&gt;&lt;a href="http://pygroup-ag100.rhcloud.com"&gt;期中課程評量系統&lt;/a&gt;&lt;/h2&gt;</summary><category term="上課內容"></category></entry><entry><title>20161028W7</title><link href="./20161028w7.html" rel="alternate"></link><published>2016-10-28T12:00:00+08:00</published><updated>2016-10-28T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-10-28:./20161028w7.html</id><summary type="html">&lt;h2&gt;使用Trace Point計算路徑&lt;h2&gt;
&lt;iframe src="https://player.vimeo.com/video/190090265" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;路徑圖&lt;/p&gt;
&lt;a&gt;&lt;img src="../data/image/Trace Point.PNG" width="800" /&gt;

&lt;h2&gt;解決子模組設定的問題&lt;/h2&gt;
&lt;p&gt;把以下多餘的子模組刪掉&lt;/p&gt;
&lt;pre&gt;
[submodule "2016fallcadp_hw"]
    path = 2016fallcadp_hw
    url = https://github.com/40423226/2016fallcadp_hw.git
    branch = gh-pages
&lt;/pre&gt;
&lt;p&gt;更改後為以下的內容&lt;/p&gt;
&lt;pre&gt;
[submodule "40423206"]
    path = 40423206
    url = https://github.com/40423206/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423224"]
    path = 40423224
    url = https://github.com/40423224/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423226"]
    path = 40423226
    url = https://github.com/40423226/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423229"]
    path = 40423229
    url = https://github.com/40423229/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423214"]
    path = 40423214
    url = https://github.com/40423214/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423216"]
    path = 40423216
    url = https://github.com/40423216/2016fallcadp_hw.git
    branch = gh-pages
&lt;/pre&gt;</summary><category term="上課內容"></category><category term="解決問題"></category><category term="子模組"></category></entry><entry><title>20161021W6</title><link href="./20161021w6.html" rel="alternate"></link><published>2016-10-21T12:00:00+08:00</published><updated>2016-10-21T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-10-21:./20161021w6.html</id><summary type="html">&lt;h2&gt;解決子模組在對應上的問題&lt;/h2&gt;

&lt;p&gt;因為之前的2016fallcadp_hw倉儲少複製了一些東西,刪除舊的倉儲後,重新做一個和之前倉儲同名的2016fallcadp_hw倉儲,但是在小組倉儲所連結的子模組,抓不到新倉儲連結,所以我們需要重新加入一次組員倉儲的資料&lt;/p&gt;

&lt;p&gt;以為只要再輸入一次指令就可以讓程式抓最新的子模組近來&lt;/p&gt;

&lt;pre&gt;
Y:\tmp\2016fallcadp_bg6&gt;git submodule add -b gh-pages https://github.com/40423226/2016fallcadp_hw.git 40423226
'40423226' already exists in the index
&lt;/pre&gt;

&lt;p&gt;但是程式告訴我們40423226的子模組已經在裡面,所以在試著用git rm 40423226 -f 來刪除存放該子模組資料的資料夾,然後再git submodule add的一次組員倉儲的資料&lt;/p&gt;

&lt;pre&gt;
Y:\tmp\2016fallcadp_bg6&gt;git submodule add -b gh-pages https://github.com/40423226/2016fallcadp_hw.git 40423226
A git directory for '40423226' is found locally with remote(s):
  origin        https://github.com/40423226/2016fallcadp_hw.git
If you want to reuse this local git directory instead of cloning again from
  https://github.com/40423226/2016fallcadp_hw.git
use the '--force' option. If the local git directory is not the correct repo
or you are unsure what this means choose another name with the '--name' option.
&lt;/pre&gt;

&lt;p&gt;程式告訴我們還有資料沒刪除乾淨,於是我們再執行一次刪除的指令&lt;/p&gt;

&lt;pre&gt;
Y:\tmp\2016fallcadp_bg6&gt;git rm 40423226 -f
fatal: pathspec '40423226' did not match any files
&lt;/pre&gt;

&lt;p&gt;然而程式說找不到任何有關該名稱的文件資料,後來我們發現submodule內的設定並沒有也因此刪除,要刪除submodule的設定有兩個方法&lt;/p&gt;

&lt;h3&gt;解決方法一&lt;/h3&gt;

&lt;p&gt;從SciTE打開,在2016fallcadp_bg6資料夾內的.gitmodules檔案,把該組員的子模組設定刪除後就可以存檔&lt;/p&gt;

&lt;pre&gt;
[submodule "40423206"]
    path = 40423206
    url = https://github.com/40423206/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423224"]
    path = 40423224
    url = https://github.com/40423224/2016fallcadp_hw.git
    branch = gh-pages
[submodule "2016fallcadp_hw"]
    path = 2016fallcadp_hw
    url = https://github.com/40423226/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423229"]
    path = 40423229
    url = https://github.com/40423229/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423214"]
    path = 40423214
    url = https://github.com/40423214/2016fallcadp_hw.git
    branch = gh-pages
[submodule "40423216"]
    path = 40423216
    url = https://github.com/40423216/2016fallcadp_hw.git
    branch = gh-pages
&lt;/pre&gt;

&lt;p&gt;如果有打下面的指令,把各組員子模組的資料抓近來,記得要把2016fallcadp_bg6\.git\modules裡該組員的隱藏資料夾刪掉&lt;/p&gt;

&lt;pre&gt;
git submodule update --init --recursive
&lt;/pre&gt;

&lt;p&gt;就可以重新執行指令,把組員的子模組加進來&lt;/p&gt;

&lt;pre&gt;
git submodule add -b gh-pages https://github.com/40423226/2016fallcadp_hw.git 40423226
&lt;/pre&gt;

&lt;h3&gt;解決方法二&lt;/h3&gt;

&lt;p&gt;直接依序執行以下的指令&lt;/p&gt;

&lt;pre&gt;
git submodule deinit asubmodule    
git rm asubmodule
# Note: asubmodule (no trailing slash)
# or, if you want to leave it in your working tree
git rm --cached asubmodule
&lt;/pre&gt;

&lt;p&gt;但是在2016fallcadp_bg6\.git\modules裡的隱藏資料夾,還是需要自己動手刪除&lt;/p&gt;</summary><category term="上課內容"></category><category term="解決問題"></category><category term="子模組"></category></entry><entry><title>20161014W5</title><link href="./20161014w5.html" rel="alternate"></link><published>2016-10-14T12:00:00+08:00</published><updated>2016-10-14T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-10-14:./20161014w5.html</id><summary type="html">&lt;h2&gt;初步認識SolveSpace&lt;h2&gt;
&lt;iframe src="https://player.vimeo.com/video/190087085" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="上課內容"></category><category term="SolveSpace"></category></entry><entry><title>20161007W4</title><link href="./20161007w4.html" rel="alternate"></link><published>2016-10-07T12:00:00+08:00</published><updated>2016-10-07T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-10-07:./20161007w4.html</id><summary type="html">&lt;h2&gt;設定使用者資料,讓可攜程式更方便&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/190072906" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;用2016fallcadp_bg6的名稱,建立小組倉儲&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/190075715" width="640" height="347" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="上課內容"></category></entry><entry><title>20160930W3</title><link href="./20160930w3.html" rel="alternate"></link><published>2016-09-30T12:00:00+08:00</published><updated>2016-09-30T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-09-30:./20160930w3.html</id><summary type="html">&lt;h2&gt;複製網誌和簡報的設定檔到2016fallcadp_hw的倉儲&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/190065696" width="640" height="347" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;更改2016fallcadp_hw的README.md檔案&lt;/h2&gt;

&lt;pre&gt;簡報: https://40423226.github.io/2016fallcadp_hw
網址: https://40423226.github.io/2016fallcadp_hw/blog/&lt;/pre&gt;

&lt;iframe src="https://player.vimeo.com/video/190066620" width="640" height="347" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;解決近端設定代理主機的問題&lt;/h2&gt;

&lt;p&gt;每次上課須執行以下指令&lt;/p&gt;

&lt;pre&gt;
git config --global http.proxy http://proxy.mde.tw:3128
git config --global https.proxy http://proxy.mde.tw:3128
&lt;/pre&gt;

&lt;p&gt;輸入完之後出現了這個問題&lt;/p&gt;

&lt;pre&gt;
warning: http.proxy has multiple values
error: cannot overwrite multiple values with a single value
       Use a regexp, --add or --replace-all to change http.proxy.
&lt;/pre&gt;

&lt;p&gt;發現在Y:\home的.gitconfig檔案出現問題,從SciTE打開.gitconfig&lt;/p&gt;

&lt;pre&gt;
[http]
    proxy = 
    proxy = 
    proxy = 
    proxy = http://proxy.mde.tw:3128
[https]
    proxy = http://proxy.mde.tw:3128
[user]
    email = 40423226@gm.nfu.edu.tw
    name = 40423226
&lt;/pre&gt;

&lt;p&gt;更正後儲存
&lt;pre&gt;
[http]
    proxy = http://proxy.mde.tw:3128
[https]
    proxy = http://proxy.mde.tw:3128
[user]
    email = 40423226@gm.nfu.edu.tw
    name = 40423226
&lt;/pre&gt;&lt;/p&gt;</summary><category term="上課內容"></category><category term="解決問題"></category><category term="環境設定"></category></entry><entry><title>20160923W2</title><link href="./20160923w2.html" rel="alternate"></link><published>2016-09-23T12:00:00+08:00</published><updated>2016-09-23T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-09-23:./20160923w2.html</id><summary type="html">&lt;h2&gt;建立40423226.github.io名稱的倉儲&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/190063679" width="640" height="347" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;把分支的預設值改為gh-pages&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/190064489" width="640" height="347" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="上課內容"></category></entry><entry><title>20160916W1</title><link href="./20160916w1.html" rel="alternate"></link><published>2016-09-16T12:00:00+08:00</published><updated>2016-09-16T12:00:00+08:00</updated><author><name>40423226</name></author><id>tag:,2016-09-16:./20160916w1.html</id><summary type="html">&lt;h2&gt;利用中秋連假複習之前學過的指令&lt;/h2&gt;

&lt;p&gt;切換到2016fallcadp_hw的分支&lt;/p&gt;

&lt;pre&gt;cd &lt;u&gt;分支名稱&lt;/u&gt;
(例如:cd 2016fallcadp_hw)&lt;/pre&gt;

&lt;p&gt;回到上一個分支&lt;/p&gt;

&lt;pre&gt;cd ..&lt;/pre&gt;

&lt;p&gt;會新建一個40423226的資料夾,並把遠端資料存在裡面&lt;/p&gt;

&lt;pre&gt;git clone &lt;u&gt;倉儲網址&lt;/u&gt; &lt;u&gt;分支名稱&lt;/u&gt;
(例如:git clone https://github.com/40423226/2016fallcadp_hw.git 40423226)&lt;/pre&gt;

&lt;p&gt;檢查分支&lt;/p&gt;

&lt;pre&gt;git branch&lt;/pre&gt;

&lt;p&gt;建立一個gh-pages名稱的分支&lt;/p&gt;

&lt;pre&gt;git branch &lt;u&gt;分支名稱&lt;/u&gt;
(例如:git branch gh-pages)&lt;/pre&gt;

&lt;p&gt;切換到指定的gh-pages分支&lt;/p&gt;

&lt;pre&gt;git checkout &lt;u&gt;分支名稱&lt;/u&gt;
(例如:git checkout gh-pages)&lt;/pre&gt;

&lt;pre&gt;git add -A&lt;/pre&gt;

&lt;pre&gt;git commit -m"&lt;u&gt;改版內容&lt;/u&gt;"
(例如:git commit -m"yen.leo update")&lt;/pre&gt;

&lt;p&gt;推送進端資料到遠端,並且指定推送到gh-pages的分支&lt;/p&gt;

&lt;pre&gt;git push origin &lt;u&gt;分支名稱&lt;/u&gt;
(例如:git push origin gh-pages)&lt;/pre&gt;

&lt;pre&gt;git pull&lt;/pre&gt;

&lt;p&gt;收尋該檔案名稱,並逐一確認是否刪除&lt;/p&gt;

&lt;pre&gt;git rm &lt;u&gt;檔案名稱&lt;/u&gt;&lt;/pre&gt;

&lt;p&gt;回到之前072e3af的版本資料&lt;/p&gt;

&lt;pre&gt;git reset --hard &lt;u&gt;版本代碼&lt;/u&gt;
(例如:git reset --hard 072e3af)&lt;/pre&gt;

&lt;p&gt;直接刪除所有該檔案名稱的檔案&lt;/p&gt;

&lt;pre&gt;git rm &lt;u&gt;檔案名稱&lt;/u&gt; -f&lt;/pre&gt;</summary><category term="上課內容"></category></entry><entry><title>Other</title><link href="./other.html" rel="alternate"></link><published>1111-11-11T11:11:00+08:06</published><updated>1111-11-11T11:11:00+08:06</updated><author><name>40423226</name></author><id>tag:,1111-11-11:./other.html</id><summary type="html">&lt;h2&gt;使用環境設定&lt;/h2&gt;

&lt;pre&gt;
git config --global http.proxy http://proxy.mde.tw:3128
git config --global https.proxy http://proxy.mde.tw:3128
git config --global user.email "40423226@gm.nfu.edu.tw"
git config --global user.name "40423226"&lt;/pre&gt;

&lt;h2&gt;子模組&lt;/h2&gt;

&lt;p&gt;用40423226的名稱把https://github.com/40423226/2016fallcadp_hw的倉儲加入為子模組&lt;/p&gt;

&lt;pre&gt;git submodule add -b gh-pages &lt;u&gt;子模組網址&lt;/u&gt; &lt;u&gt;子模組名稱&lt;/u&gt;
(例如:git submodule add -b gh-pages https://github.com/40423226/2016fallcadp_hw 40423226)&lt;/pre&gt;

&lt;p&gt;抓對應子模組的版本&lt;/p&gt;

&lt;pre&gt;git submodule update --init --recursive&lt;/pre&gt;

&lt;p&gt;更新子模組的資料,甚至更新子模組裡子模組的資料&lt;/p&gt;

&lt;pre&gt;git submodule foreach "(git checkout gh-pages; git pull)&amp;"&lt;/pre&gt;

&lt;h2&gt;HTML文字語法&lt;/h2&gt;

&lt;h1&gt;h1&lt;/h1&gt;

&lt;h2&gt;h2&lt;/h2&gt;

&lt;h3&gt;h3&lt;/h3&gt;

&lt;h4&gt;h4&lt;/h4&gt;

&lt;h5&gt;h5&lt;/h5&gt;

&lt;h6&gt;h6&lt;/h6&gt;

&lt;pre&gt;
&amp;lt;h1&gt;h1&amp;lt;/h1&gt;
&amp;lt;h2&gt;h2&amp;lt;/h2&gt;
&amp;lt;h3&gt;h3&amp;lt;/h3&gt;
&amp;lt;h4&gt;h4&amp;lt;/h4&gt;
&amp;lt;h5&gt;h5&amp;lt;/h5&gt;
&amp;lt;h6&gt;h6&amp;lt;/h6&gt;
&lt;/pre&gt;

&lt;p align="center"&gt;置中&lt;/p&gt;

&lt;pre&gt;&amp;lt;p align="center"&gt;置中&amp;lt;/p&gt;&lt;/pre&gt;

&lt;p align="right"&gt;靠右&lt;/p&gt;

&lt;pre&gt;&amp;lt;p align="right"&gt;靠右&amp;lt;/p&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;粗體&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;b&gt;粗體&amp;lt;/b&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;斜體&lt;/i&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;i&gt;斜體&amp;lt;/i&gt;&lt;/pre&gt;

&lt;p&gt;&lt;u&gt;底線&lt;/u&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;u&gt;底線&amp;lt;/u&gt;&lt;/pre&gt;</summary><category term="環境設定"></category><category term="子模組"></category><category term="HTML文字語法"></category></entry></feed>